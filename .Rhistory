# Welcome to R! ####
# The hashtag (#) at the beginning of this line means R doesn't run it.
"But this line is run by R" # Hit Ctrl+Enter to see what I mean. (This runs the current line or highlighted section)
#First let's start with some basic math:
1+1
#Don't forget to hit Crtl + Enter, and no need for the '=' here. The equal symbol has a different meaning in scripts.
# A double '=' will tell you if the equation is right - try running the next two lines:
1+1==1+1
1+1==1+2
# Other arithmetic works the same way - run the following lines:
2*10
10/2
2^10
#But what if you want to save the answer to one of these equations? You can create an 'object' in R with '<-' as follows:
a <- 2+2
a
a <- c(1,1,2,3,5)
a
# Notice that we have over-written our value of 'a' from earlier. Remember this feature of R.
# TIP: If you are unsure what a function will do, you can use the built-in R help files with a question mark:
?c
# Now to confirm the object created has been 'read' by R in the format we expect we will use the typeof() function:
typeof(a)
# Now see what happens if we add a non-numeric value to the c() function. Don't forget the quotation marks:
b <- c(1,1,2,3,x)
# Without quotes the text is read as an object by R and creates an error, even if an object with that value does not exist.
b <- c(1,1,2,3,'x')
b
typeof(b)
# We can 'force' R to read the numbers as numeric values, but it removes text values from the vector.
as.numeric(b)
## Factors ##
# Factors represent categorical values with a fixed number of "levels".
# These levels do not need to have a low-high value gradient (e.g. could be colors).
# Factors can be created with the nice and direct "factor" function:
c <- factor(b)
c
# Factors are built on top of vector integers. This really is not important for our purposes, except:
typeof(c)
# results in an output of "integer". So keep this in mind, and a second test of:
is.factor(c)
a <- c(0,1,1,2,3,5,8,13,21)
b <- c(8,8,8,4,4,4,2,2,2)
c <- c('a','a','a','b','b','b','c','c','c')
d <- c("Brighton","Notts","Ipswich","Luton","Burton","Oldham","Oxford","Bristol","Leyton")
data <- cbind(a,b,c,d)
data
#To reformat the data to allow for numeric values we will use the as.data.frame() function:
df <- as.data.frame(data)
df
# 'df' is an abbreviation for 'data frame' that is commonly used by R coders for creating examples.
# Notice how the quotation marks are no longer present.
# Also notice this now looks like a table. To the left of the values are row names and to the top are column names.
# Row names default to a numeric count and column names are the vector object names as combined.
# Let's change the column and row names to something more descriptive, starting with columns.
# To only change part of the data frame, we will need a function on both sides of '<-' to direct where the change occurs:
colnames(df) <- c("Fibonacci", "Division", "Factors", "Foosball")
df
# Next we will change the row names to be represented by towns with sporty teams instead:
row.names(df) <- df$Foosball
df
# Now it seems a bit silly to have these towns listed both in the data frame itself and as row names, so let's delete the town column.
# To do this we can delete the column or overwrite the existing df object with a subset of the data frame.
# A subset is a portion of the original R object based on some selection criteria.
# So let's start with how to select part of a data frame using the [row, column] method in R:
df[1,]
#Versus:
df[,1]
#The location of your comma is very important - the first operation selects a row and the second a column.
# Or, for a single cell:
df[1,1]
# Or, for multiple rows or columns we can use a colon:
df[1:2,]
# Or, for multiple rows or columns we can use a colon:
df[1:2,]
df[,1:2]
# To remove a column or row we will use the minus (-) symbol:
df[-1,]
df[,-1]
# We can also select specific columns or rows by name:
df[c("Brighton"),]
df[,c("Fibonacci")]
# So to remove the "Foosball" column we have two options with the same result:
df.a <- df[,1:3]
df.a
#OR#
df.b <- df[,-4]
df.b
#OR#
df.c <- df[,c("Fibonacci", "Division", "Factors")]
df.c
#Notice removing by name doesn't work the same? This is a quirk of the language underlying R and we will look at work-arounds later in the semester.
df.d <- df[,-c("Foosball")]
# If you want to be absolutely sure the results are identical, we can use the double equals (==) logical to check all cells:
df.a == df.b
# All cells return a "TRUE" value so the data frames are identical.
#To test all three data frames at the same time you need to treat these like Boolean operators and "add" the logical statements with an "and"
df.a == df.b & df.a == df.c
# All cells return a "TRUE" value so the data frames are identical.
#To test all three data frames at the same time you need to treat these like Boolean operators and "add" the logical statements with an "and"
df.a == df.b & df.a == df.c
# What if you want your columns as rows and rows as columns (i.e. transposed)? Simply:
df.t <- t(df.a)
df.t
binary.solo <- c(0,0,0,0,0,0,1,1,1)
new.df <- cbind(df.a, binary.solo)
new.df
Chelsea <- data.frame(34,1,"d")
Chelsea
# The names of columns do not match, so we need to correct this before binding:
colnames(Chelsea) <- colnames(df.a)
df.r <- rbind(df.a, Chelsea)
df.r
#Great! But notice the new row name? We can fix that with a combination of multiple functions we've learned:
row.names(df.r) <- c(row.names(df.a[1:9,]),"Chelsea")
df.r
# Look closely at the above operation. We have nested a subset function "df.a[1:9,]" within the row.names() function
# This is then nested within the c() function to bind all values into a single vector and replaces the row names.
#You can run individual parts of the nested functions to better understand what is happening:
df.a[1:9,]
#Calling the first 9 rows of the data frame
row.names(df.a[1:9,])
#now grabbing only the row names of those 9 rows.
#this can also be done manually with copy-paste and adding commas...but why would you go to all this effort?
c(row.names(df.a[1:9,]),"Chelsea") == c("Brighton","Notts","Ipswich","Luton","Burton","Oldham","Oxford","Bristol","Leyton","Chelsea")
# For example, say you would like to know how each Division value compares to the mean Fibonacci within our data frame:
ratio <- df.r$Division/mean(df.r$Fibonacci) #ratio by a single value
ratio
# For example, say you would like to know how each Division value compares to the mean Fibonacci within our data frame:
ratio <- df.r$Division/mean(df.r$Fibonacci) #ratio by a single value
by.row <- df.r$Division/df.r$Fibonacci #for comparing values within individual samples against each other.
by.row
df.r <- cbind(df.r, by.row)
df.r
# The summary() function will produce an output with basic descriptive statistics of our data frame or other R objects:
summary(df.r)
# The head() function will display the first 6 rows of a data frame in the console below. This will be handy for very large data frames:
head(df.r)
# You can also check the dimensions of your data frame with the 'number of rows' and 'number of columns' functions:
nrow(df.r)
ncol(df.r)
#If you would like to inspect the data frame more closely and have difficulty with the console display, try View():
View(df.r)
# Replace "wilsonmj" with your repository name, this should be your lastname+first initial+middle initial.
### If you are using a mac replace the 'C:' at the beginning of the directory with '~':
# If this does not work, then remove the '~' at the beginning of the folder path.
#Replace my working directory with yours.
setwd("~/GitHub/knisssj/Week1")
write.csv(df.r, file = "Example.csv")
setwd("~/GitHub/knisssj/Week1")
setwd("~/Documents/GitHub/knisssj")
setwd("~/Documents/GitHub/knisssj")
setwd("~/Documents/GitHub/knisssj/Week1")
setwd("~/Documents/GitHub/knisssj")
setwd("~/Documents/GitHub/knisssj")
getwd()
cv1 <- c(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
cv1
cv1 <- c("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o")
cv1
cv2 <- c("a","a","a","a","a","b","b","b","b","b","c","c","c","c","c")
cv2
nv1 <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
nv1
nv2 <- c(1,1,2,2,3,3,4,4,5,5,6,6,6,6,6)
nv2
nv3 <- c(1,1.1,1.2,3,4,5,6.7,7.23,8,10,11.1,13,14,14.23,15)
nv3
datask <- cbind(cv1,cv2,nv1,nv2,nv3)
datask
dfsk <- as.data.frame(datask)
dfsk
colnames(dfsk) <- c("Letter","Repeats","Number","Category","Value")
dfsk
row.names(dfsk) <- df$Letter
dfsk
dfsk
row.names(dfsk) <- df$cv1
dfsk
row.names(dfsk) <- dfsk$Letter
dfsk
dfsk.a <- dfsk[,-5]
dfsk.a
dfsk.a <- dfsk[,-1]
dfsk.a
newclmn <- (0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.11,0.12,0.13,0.14,0.15)
newclmn <- c(0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.11,0.12,0.13,0.14,0.15)
newclmn
newrow <- c(0.0,0.1,0.2,0.3)
newrow
p <- data.frame(0.1,0.0,0.2,0.3)
p
dfsk.a
p <- data.frame(c,16,6,15.22)
p
dfsk.a
p <- data.frame("c",16,6,15.22)
p
colnames(p) <- colnames(dfsk.a)
dfsk.r <- rbind(dfsa.a,p)
dfsk.r <- rbind(dfsk.a,p)
dfsk.r
dfsk.r <- rbind(dfsk.a, p)
dfsk.r
row.names(dfsk.r) <- c(row.names(dfsk.a[1:15,]),"p")
dfsk.r
write.csv(dfsk.r, file = "Kniss_Week1_Assignment.csv")
summary(dfsk.r)
