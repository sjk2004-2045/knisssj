# To use packages in R they must be installed on your computer. There are two ways to do this.
# (1) - From the "Packages" tab in the bottom right pane, click the "Install" button and type the package name into the dialog box.
# (2) - To install directly from the script (remember RStudio didn't always exist) use the install.packages() function:
install.packages("ggplot2")
# For comparison, we'll use the data and figure from last week - reloaded here:
unique.char <- c('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o')
group.char <- c('x','x','x','x','y','y','y','z','z','z','z','z','z','z','z')
uniqu.num <- c(0,1,1,2,3,5,8,13,21,34,55,89,144,233,377)
rep.num <- c(1,2,3,1,2,3,1,2,3,5,2,3,4,0,5)
dec.num <- c(1,2.1,3.1,1.2,2.3,3.5,1.8,2.13,3.21,5.34,2.55,3.89,4.144,0.233,5.377)
df <- as.data.frame(cbind(unique.char,group.char,uniqu.num,rep.num,dec.num))
df$uniqu.num <- as.numeric(as.character(df$uniqu.num))
df$rep.num <- as.numeric(as.character(df$rep.num))
df$dec.num <- as.numeric(as.character(df$dec.num))
add.row <- data.frame("p","z",610,4,4.610)
colnames(add.row) <- colnames(df)
df1 <- rbind(df, add.row)
row.names(df1) <- df1$unique.char
df1 <- df1[,-1]
df1
# And recreate the plot we made with the "base" R function (i.e. not from a package):
par(family = "serif")
#Then replot
plot(df1$dec.num ~ df1$uniqu.num, xlab = "Explanatory", ylab = "Response", main = "My Favorite Scatter Plot",
cex.axis=0.8, cex.main = 0.5, cex.lab = 1.25, pch=17, col = "grey40", cex = 1.5)
# To use packages in R they must be installed on your computer. There are two ways to do this.
# (1) - From the "Packages" tab in the bottom right pane, click the "Install" button and type the package name into the dialog box.
# (2) - To install directly from the script (remember RStudio didn't always exist) use the install.packages() function:
install.packages("ggplot2")
# install.packages requires the package name to be in quotation marks.
#Next you need to tell R to "load" the package using the library() function.
#It would take too much RAM to run all of you packages all the time, so this allows you to pick and choose based on what you are doing at any point in time.
library(ggplot2)
# From the reference manual you can find the basic plotting function is ggplot():
# Let's try replotting last week's data with ggplot():
ggplot(df1, aes(x=uniqu.num, y=dec.num))
# SO...where are the data???
# Unlike base R plotting, ggplot requires EVERYTHING to be specified.
# Let's try again by adding the points, literally with a +:
ggplot(df1, aes(x=uniqu.num, y=dec.num)) +
geom_point(size=2, shape=23)
# So far this looks pretty similar to our base plot, so why go to the trouble?
# All of the additional items you can now easily add to the plot (including analyses) are the power of ggplot:
# Let's add a regression line to these data following a linear model ("lm"):
ggplot(df1, aes(x=uniqu.num, y=dec.num)) +
geom_point(size=2, shape=23) +
geom_smooth(method = lm)
# googleVis ####
# googleVis is a package that - as the name suggests - is support by Google.
# This packages uses the Google API (application programmer interface) and Java wizardry to create interactive plots.
# The majority of functions in this package will automatically open a browser window - so be prepared for that.
#First, install the package.
install.packages("googleVis")
library(googleVis)
# Because the functions are alphabetical, the example data set for Hurricane Andrew is at the top.
# It includes a mapping example - something we have not done yet so let's see what it looks like:
# This is a direct copy-paste from the reference manual to explore an example usage.
# Run the following 14 lines and a browser window should open with the result.
data(Andrew)
AndrewGeoMap <- gvisGeoMap(Andrew, locationvar='LatLong', numvar='Speed_kt',
hovervar='Category',
options=list(width=800,height=400,
region='US', dataMode='Markers'))
AndrewMap <- gvisMap(Andrew, 'LatLong' , 'Tip',
options=list(showTip=TRUE, showLine=TRUE,
enableScrollWheel=TRUE,
mapType='hybrid', useMapTypeControl=TRUE,
width=800,height=400))
AndrewTable <- gvisTable(Andrew,options=list(width=800))
# Combine the outputs into one page:
AndrewVis <- gvisMerge(AndrewGeoMap, AndrewMap)
plot(AndrewVis)
# Next is an example dataset called "Cairo" that includes an interactive calendar.
# That sounds interesting, so let's take a look with the example script:
data(Cairo)
plot(gvisCalendar(Cairo))
# The "Cats" dataset and word tree example sound like a completely different figure than we've talked about.
# Let's see what it does:
data(Cats)
plot(gvisWordTree(Cats, textvar = "Phrase"))
# Annotated Timeline ####
# This particular function caught my eye as many data in ecology are time series-based.
# First, let's run the example:
data(Stock)
A1 <- gvisAnnotatedTimeLine(Stock, datevar="Date",
numvar="Value", idvar="Device",
titlevar="Title", annotationvar="Annotation",
options=list(displayAnnotations=TRUE,
legendPosition='newRow',
width="600px", height="350px")
)
plot(A1)
# This plot seems like it might be a great way to explore hydrograph (stream flow) data over time.
# But look in the console - there is a red message that this function has been updated.
# Try the new gvisAnnotationChart() function instead:
A1 <- gvisAnnotationChart(Stock, datevar="Date",
numvar="Value", idvar="Device",
titlevar="Title", annotationvar="Annotation",
options=list(displayAnnotations=TRUE,
legendPosition='newRow',
width="600px", height="350px")
)
plot(A1)
# Creating a hydrograph ####
# The USGS manages flow gauges across the US that capture discharge rates every 15 minutes.
# USGS scientists have created a package called "dataRetrieval" that will pull data directly from the USGS website for analysis.
# However, the USGS published their package to GitHub instead of CRAN.
# Reading packages from GitHub requires the "devtools" package so first:
install.packages("devtools")
library(devtools)
# Then use the install_github() function to download the "dataRetrieval" package from the "USGS-R" GitHub site.
install_github("USGS-R/dataRetrieval")
# Hit an empty line in the Console to skip updates
library(dataRetrieval)
# The function we need from this package for pulling flow data is called readNWISuv():
# NWIS stands for National Water Information System
?readNWISuv
# From this, you can see the function collects data based on the USGS codes for location and date type based on a date range.
#We will look at the 2011 flood on the Susquehanna River in Sunbury compared to several months before and after the flood:
# The site code for Sunbury is "01554000".
# This line could take a minute or two depending on your internet connection speed.
sunbury_flow <- readNWISuv("01554000","00060","2011-01-01","2013-10-10")
# From this, you can see the function collects data based on the USGS codes for location and date type based on a date range.
#We will look at the 2011 flood on the Susquehanna River in Sunbury compared to several months before and after the flood:
# The site code for Sunbury is "01554000".
# This line could take a minute or two depending on your internet connection speed.
sunbury_flow <- readNWISuv("01554000","00060","2011-01-01","2013-10-10")
#This is a very large file, let's use head() to look at the format:
head(sunbury_flow)
# How big is it? We can check the length with the nrow() function:
nrow(sunbury_flow)
#We'll overwrite the original, and make it wider for clarity:
flowchart <- gvisAnnotationChart(sunbury_flow, datevar="dateTime",
numvar="X_00060_00000",
options=list(displayAnnotations=FALSE,
legendPosition='newRow',
width="900px", height="400px")
)
# Notice all I have changed is the date range in the readNWISuv() function:
sunbury_flow <- readNWISuv("01554000","00060","2011-09-01","2011-10-01")
#We'll overwrite the original, and make it wider for clarity:
flowchart <- gvisAnnotationChart(sunbury_flow, datevar="dateTime",
numvar="X_00060_00000",
options=list(displayAnnotations=FALSE,
legendPosition='newRow',
width="900px", height="400px")
)
plot(flowchart)
install.packages("learnPopGen")
library(learnPopGen)
genetic.drift(p0 = 0.1, Ne = 100, nrep = 4, time = 20, show = p, pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 100, nrep = 4, time = 20, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 10, nrep = 4, time = 20, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.1)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.01, ylim=(0.0,0.6))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.01, ylim=(0.0,1.0))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.01, ylim=(0,1))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 20, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 50, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
plot((genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01), ylim = (0,1))
plot((genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01), ylim = c(0.0,1.0))
plot((genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01) ylim = c(0.0,1.0))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01, ylim = c(0.0,1.0))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01, ylim = c(0.0,0.6))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01, ylim = c(0.0,0.5))
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01, main = "Genetic Drift")
pdf(file = "Week3/Kniss_packageplot1.pdf", width = 6, height = 6)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
pdf(file = "Kniss_packageplot1.pdf", width = 6, height = 6)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
dev.off()
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
kniss_wd <- function (repo, folder=NULL) {
if(missing(folder))
{
setwd(print(paste(if (Sys.info()[["sysname"]]=="Windows") {("C:/GitHub")} else {
if (Sys.info()[["sysname"]]=="Darwin"){("/Users/sylviakniss/Documents/GitHub")} else ("for Linux run: setwd('/home/[INSERT YOUR USERNAME]/GitHub')")
},"/",repo, sep = "")))}
else
{
setwd(print(paste(if (Sys.info()[["sysname"]]=="Windows") {("C:/GitHub")} else {
if (Sys.info()[["sysname"]]=="Darwin"){("/Users/sylviakniss/Documents/GitHub")} else ("for Linux run: setwd('/home/[INSERT YOUR USERNAME]/GitHub')")
},"/",repo, "/", folder, sep = "")))}
}
kniss_wd(repo = "knisssj", folder = "Week3")
install.packages("learnPopGen")
library(learnPopGen)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
pdf(file = "Kniss_packageplot1.pdf", width = 6, height = 6)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
dev.off()
pdf(file = "Kniss_packageplot2.pdf", width = 6, height = 6)
genetic.drift(p0 = 0.1, Ne = 200, nrep = 4, time = 100, show = "p", pause = 0.01)
dev.off()
setwd("C:/GitHub/R4Eco_2024/Week6")
df <- read.csv("Uchidaetal_2019_Data.csv")
# Take a look and see what our data look like this week:
head(df)
#Generalized Linear MIXED model: ####
# The authors used ANOVAs to test the significance of different potential 'predators' in generating a flight response among squirrels
# They also tested this across rural or urban locations in several regions.
# They did not, however, consider individual variation in the models - i.e. some squirrels are actually scaredy cats.
# So we are going to test if there is a random effect of individual on their results that was not picked up by the ANOVAs
#First install and load these two packages - they work in tandem with each other.
library(MASS)
library(MuMIn)
# We are going to use the glmmPQL() function as it is designed to handle non-normal data in a linear model.
# However, the "PQL" in the glmmPQL() function stands for "Penalized Quasi-Likelihood".
# The "quasi" likelihood unfortunately means a "correct" answer is more difficult to find.
# It also means our standard R-squared and p-values are a little more difficult to calculate,
# so we will be using some specialized functions.
# For more details on this particular function:
?glmmPQL
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
# We can still use the summary() function to look at results:
summary(glmm.mod)
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
#Generalized Linear MIXED model: ####
# The authors used ANOVAs to test the significance of different potential 'predators' in generating a flight response among squirrels
# They also tested this across rural or urban locations in several regions.
# They did not, however, consider individual variation in the models - i.e. some squirrels are actually scaredy cats.
# So we are going to test if there is a random effect of individual on their results that was not picked up by the ANOVAs
#First install and load these two packages - they work in tandem with each other.
library(MASS)
#Generalized Linear MIXED model: ####
# The authors used ANOVAs to test the significance of different potential 'predators' in generating a flight response among squirrels
# They also tested this across rural or urban locations in several regions.
# They did not, however, consider individual variation in the models - i.e. some squirrels are actually scaredy cats.
# So we are going to test if there is a random effect of individual on their results that was not picked up by the ANOVAs
#First install and load these two packages - they work in tandem with each other.
install.packages("MASS")
install.packages("MASS")
install.packages("MuMIn")
install.packages("MuMIn")
library(MASS)
library(MuMIn)
# We are going to use the glmmPQL() function as it is designed to handle non-normal data in a linear model.
# However, the "PQL" in the glmmPQL() function stands for "Penalized Quasi-Likelihood".
# The "quasi" likelihood unfortunately means a "correct" answer is more difficult to find.
# It also means our standard R-squared and p-values are a little more difficult to calculate,
# so we will be using some specialized functions.
# For more details on this particular function:
?glmmPQL
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
# We can still use the summary() function to look at results:
summary(glmm.mod)
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
setwd("C:/GitHub/R4Eco_2024/Week6")
df <- read.csv("Uchidaetal_2019_Data.csv")
# Take a look and see what our data look like this week:
head(df)
#Generalized Linear MIXED model: ####
# The authors used ANOVAs to test the significance of different potential 'predators' in generating a flight response among squirrels
# They also tested this across rural or urban locations in several regions.
# They did not, however, consider individual variation in the models - i.e. some squirrels are actually scaredy cats.
# So we are going to test if there is a random effect of individual on their results that was not picked up by the ANOVAs
#First install and load these two packages - they work in tandem with each other.
install.packages("MASS")
install.packages("MuMIn")
library(MASS)
library(MuMIn)
# We are going to use the glmmPQL() function as it is designed to handle non-normal data in a linear model.
# However, the "PQL" in the glmmPQL() function stands for "Penalized Quasi-Likelihood".
# The "quasi" likelihood unfortunately means a "correct" answer is more difficult to find.
# It also means our standard R-squared and p-values are a little more difficult to calculate,
# so we will be using some specialized functions.
# For more details on this particular function:
?glmmPQL
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
setwd("C:/GitHub/knisssj")
kniss_wd <- function (repo, folder=NULL) {
if(missing(folder))
{
setwd(print(paste(if (Sys.info()[["sysname"]]=="Windows") {("C:/GitHub")} else {
if (Sys.info()[["sysname"]]=="Darwin"){("/Users/sylviakniss/Documents/GitHub/")} else ("for Linux run: setwd('/home/[INSERT YOUR USERNAME]/GitHub')")
},"/",repo, sep = "")))}
else
{
setwd(print(paste(if (Sys.info()[["sysname"]]=="Windows") {("C:/GitHub")} else {
if (Sys.info()[["sysname"]]=="Darwin"){("/Users/sylviakniss/Documents/GitHub/")} else ("for Linux run: setwd('/home/[INSERT YOUR USERNAME]/GitHub')")
},"/",repo, "/", folder, sep = "")))}
}
kniss_wd(repo = "knisssj")
df <- read.csv("Uchidaetal_2019_Data.csv")
kniss_wd(repo = "R4Eco_Indie")
df <- read.csv("Uchidaetal_2019_Data.csv")
df <- read.csv("Week6/Uchidaetal_2019_Data.csv")
# Take a look and see what our data look like this week:
head(df)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
kniss_wd <- function (repo, folder=NULL) {
if(missing(folder))
{
setwd(print(paste(if (Sys.info()[["sysname"]]=="Windows") {("C:/GitHub")} else {
if (Sys.info()[["sysname"]]=="Darwin"){("/Users/sylviakniss/Documents/GitHub")} else ("for Linux run: setwd('/home/[INSERT YOUR USERNAME]/GitHub')")
},"/",repo, sep = "")))}
else
{
setwd(print(paste(if (Sys.info()[["sysname"]]=="Windows") {("C:/GitHub")} else {
if (Sys.info()[["sysname"]]=="Darwin"){("/Users/sylviakniss/Documents/GitHub")} else ("for Linux run: setwd('/home/[INSERT YOUR USERNAME]/GitHub')")
},"/",repo, "/", folder, sep = "")))}
}
kniss_wd(repo = "knisssj", folder = "Week3")
install.packages("learnPopGen")
library(learnPopGen)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01)
genetic.drift(p0 = 0.1, Ne = 120, nrep = 4, time = 100, show = "p", pause = 0.01, main = "Frequency")
# First things first, load the vegan library.
# Any time you are looking at community ecology, the package is probably going to be vegan.
library(vegan)
# We will use the "dune" dataset from vegan.
# the dune data are plant communities from dune meadows.
data(dune)
# There is also a data frame of environmental factors that match the dune plants that we will use this week:
data(dune.env)
# There is also a data frame of environmental factors that match the dune plants that we will use this week:
data(dune.env)
# We are focusing on Redundancy Analysis (RDA).
# But all of these methods can be transferred to other multivariate techniques very easily.
# pca() and cca() can typically just replace the rda() in any of these functions and models.
# The generic use of rda is very straightforward. All you need is a numeric species-by-site matrix.
dune #to see what I mean by a species-by-site matrix
# We are focusing on Redundancy Analysis (RDA).
# But all of these methods can be transferred to other multivariate techniques very easily.
# pca() and cca() can typically just replace the rda() in any of these functions and models.
# The generic use of rda is very straightforward. All you need is a numeric species-by-site matrix.
dune #to see what I mean by a species-by-site matrix
ord <- rda(dune)
plot(ord)
